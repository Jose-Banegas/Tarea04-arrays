//Recordemos que las reglas anteriores aún aplican: no puede desplazarse "hacia atrás".
package arrays;

public class Snake {

	// se considera un Snake que ocupa un solo casillero del mapa
	private int x, y;
	private boolean estaViva = true;
	private Mapa mapa;
	private Direccion ultimoMovimiento = Direccion.ARRIBA;

	/**
	 * Recibe mapa y posición inicial. El mapa contiene posiciones previamente
	 * ocupadas
	 */
	public Snake(Mapa mapa, int x, int y) {
		this.mapa = mapa;
		boolean posicionOcupada = mapa.estaOcupado(x, y);
		if(posicionOcupada)
			throw new Error("Posicion ocupada, busque nuevo valor");
		else
			this.x = x;
			this.y = y;
	}

	/**
	 * @pre debe estar viva
	 * @post si el movimiento es posible, debe desplazarse
	 * @post debe morir si tal desplazamiento no es compatible o si la posición
	 *       está ocupada
	 * @post debe actualizar el mapa en todos los casos
	 * @param direccion
	 *            , la dirección hacia la que debe moverse
	 */

	public void desplazarseHacia(Direccion direccion) {
		if (!isViva()) {
			throw new Error("Snake muerto");
		} else {
			if (direccion == Direccion.ARRIBA && this.ultimoMovimiento == Direccion.ABAJO
					|| direccion == Direccion.ABAJO	&& this.ultimoMovimiento == Direccion.ARRIBA
					|| direccion == Direccion.DERECHA && this.ultimoMovimiento == Direccion.IZQUIERDA
					|| direccion == Direccion.IZQUIERDA	&& this.ultimoMovimiento == Direccion.DERECHA)
				throw new Error("Movimiento invalido");
			if (direccion == Direccion.ARRIBA && this.ultimoMovimiento != Direccion.ABAJO) {
				if ((getY() == 0) || this.mapa.estaOcupado(getX(), getY() - 1)) {
					this.estaViva = false;
				} else {
					this.mapa.desocupar(getX(), getY());
					this.y -= 1;
					this.mapa.ocupar(getX(), getY());
				}
				this.ultimoMovimiento = Direccion.ARRIBA;
			}
			if (direccion == Direccion.ABAJO && this.ultimoMovimiento != Direccion.ARRIBA) {
				if (mapa.estaOcupado(getX(), getY() + 1)) {
					this.estaViva = false;
				} else {
					this.mapa.desocupar(getX(), getY());
					this.y += 1;
					this.mapa.ocupar(getX(), getY());
				}
				this.ultimoMovimiento = Direccion.ABAJO;
			}
			if (direccion == Direccion.DERECHA && this.ultimoMovimiento != Direccion.IZQUIERDA) {
				if (mapa.estaOcupado(getX() + 1, getY())) {
					this.estaViva = false;
				} else {
					this.mapa.desocupar(getX(), getY());
					this.x += 1;
					this.mapa.ocupar(getX(), getY());
				}
				this.ultimoMovimiento = Direccion.DERECHA;
			}
			if (direccion == Direccion.IZQUIERDA && this.ultimoMovimiento != Direccion.DERECHA) {
				if ((getX() == 0) || this.mapa.estaOcupado(getX() - 1, getY())) {
					this.estaViva = false;
				} else {
					this.mapa.desocupar(getX(), getY());
					this.x -= 1;
					this.mapa.ocupar(getX(), getY());
				}
				this.ultimoMovimiento = Direccion.IZQUIERDA;
			}
		}
	}

	// devuelve posicion en X del snake.
	public int getX() {
		return this.x;
	}

	// devuelve posicion en Y del snake.
	public int getY() {
		return this.y;
	}

	// devuelve si el snake esta vivo o no.
	public boolean isViva() {
		return this.estaViva;
	}
}

enum Direccion {
	ARRIBA, ABAJO, IZQUIERDA, DERECHA
}

class Mapa {
	private boolean[][] ocupados;

	public Mapa(int ancho, int alto) {
		ocupados = new boolean[ancho + 1][alto + 1];
		for (int i = 0; i < ocupados.length; i++) {
			ocupar(i, ocupados[i].length - 1);
		}

		for (int i = 0; i < ocupados[0].length - 1; i++) {
			ocupar(ocupados.length - 1, i);
		}
	}

	// comprueba si la coordenada (x,y) esta ocupada y devuelve el valor.
	public boolean estaOcupado(int x, int y) {
		if (ocupados[x][y]) {
			return true;
		} else {
			return false;
		}
	}

	// ocupa el casillero si anteriormente no estaba ocupado.
	public void ocupar(int x, int y) {
		if (estaOcupado(x, y))
			throw new Error("Casillero ocupado");
		else
			ocupados[x][y] = true;
	}

	// desocupa el casillero si anteriormente no estaba desocupado.
	public void desocupar(int x, int y) {
		if (estaOcupado(x, y))
			ocupados[x][y] = false;
	}
}
